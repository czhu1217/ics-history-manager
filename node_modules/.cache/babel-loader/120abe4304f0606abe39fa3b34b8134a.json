{"ast":null,"code":"/**\n * UUID.js - RFC-compliant UUID Generator for JavaScript\n *\n * @file\n * @author  LiosK\n * @version v4.2.4\n * @license Apache License 2.0: Copyright (c) 2010-2019 LiosK\n */\n\n/**\n * @class\n * @classdesc {@link UUID} object.\n * @hideconstructor\n */\nvar UUID;\n\nUUID = function (overwrittenUUID) {\n  \"use strict\"; // Core Component {{{\n\n  /**\n   * Generates a version 4 UUID as a hexadecimal string.\n   * @returns {string} Hexadecimal UUID string.\n   */\n\n  UUID.generate = function () {\n    var rand = UUID._getRandomInt,\n        hex = UUID._hexAligner;\n    return hex(rand(32), 8) // time_low\n    + \"-\" + hex(rand(16), 4) // time_mid\n    + \"-\" + hex(0x4000 | rand(12), 4) // time_hi_and_version\n    + \"-\" + hex(0x8000 | rand(14), 4) // clock_seq_hi_and_reserved clock_seq_low\n    + \"-\" + hex(rand(48), 12); // node\n  };\n  /**\n   * Returns an unsigned x-bit random integer.\n   * @private\n   * @param {number} x Unsigned integer ranging from 0 to 53, inclusive.\n   * @returns {number} Unsigned x-bit random integer (0 <= f(x) < 2^x).\n   */\n\n\n  UUID._getRandomInt = function (x) {\n    if (x < 0 || x > 53) {\n      return NaN;\n    }\n\n    var n = 0 | Math.random() * 0x40000000; // 1 << 30\n\n    return x > 30 ? n + (0 | Math.random() * (1 << x - 30)) * 0x40000000 : n >>> 30 - x;\n  };\n  /**\n   * Converts an integer to a zero-filled hexadecimal string.\n   * @private\n   * @param {number} num\n   * @param {number} length\n   * @returns {string}\n   */\n\n\n  UUID._hexAligner = function (num, length) {\n    var str = num.toString(16),\n        i = length - str.length,\n        z = \"0\";\n\n    for (; i > 0; i >>>= 1, z += z) {\n      if (i & 1) {\n        str = z + str;\n      }\n    }\n\n    return str;\n  };\n  /**\n   * Retains the value of 'UUID' global variable assigned before loading UUID.js.\n   * @since 3.2\n   * @type {any}\n   */\n\n\n  UUID.overwrittenUUID = overwrittenUUID; // }}}\n  // Advanced Random Number Generator Component {{{\n\n  (function () {\n    var mathPRNG = UUID._getRandomInt;\n    /**\n     * Enables Math.random()-based pseudorandom number generator instead of cryptographically safer options.\n     * @since v3.5.0\n     * @deprecated This method is provided only to work around performance drawbacks of the safer algorithms.\n     */\n\n    UUID.useMathRandom = function () {\n      UUID._getRandomInt = mathPRNG;\n    };\n\n    var crypto = null,\n        cryptoPRNG = mathPRNG;\n\n    if (typeof window !== \"undefined\" && (crypto = window.crypto || window.msCrypto)) {\n      if (crypto.getRandomValues && typeof Uint32Array !== \"undefined\") {\n        // Web Cryptography API\n        cryptoPRNG = function cryptoPRNG(x) {\n          if (x < 0 || x > 53) {\n            return NaN;\n          }\n\n          var ns = new Uint32Array(x > 32 ? 2 : 1);\n          ns = crypto.getRandomValues(ns) || ns;\n          return x > 32 ? ns[0] + (ns[1] >>> 64 - x) * 0x100000000 : ns[0] >>> 32 - x;\n        };\n      }\n    } else if (typeof require !== \"undefined\" && (crypto = require(\"crypto\"))) {\n      if (crypto.randomBytes) {\n        // nodejs\n        cryptoPRNG = function cryptoPRNG(x) {\n          if (x < 0 || x > 53) {\n            return NaN;\n          }\n\n          var buf = crypto.randomBytes(x > 32 ? 8 : 4),\n              n = buf.readUInt32BE(0);\n          return x > 32 ? n + (buf.readUInt32BE(4) >>> 64 - x) * 0x100000000 : n >>> 32 - x;\n        };\n      }\n    }\n\n    UUID._getRandomInt = cryptoPRNG;\n  })(); // }}}\n  // UUID Object Component {{{\n\n  /**\n   * Names of UUID internal fields.\n   * @type {string[]}\n   * @constant\n   * @since 3.0\n   */\n\n\n  UUID.FIELD_NAMES = [\"timeLow\", \"timeMid\", \"timeHiAndVersion\", \"clockSeqHiAndReserved\", \"clockSeqLow\", \"node\"];\n  /**\n   * Sizes of UUID internal fields.\n   * @type {number[]}\n   * @constant\n   * @since 3.0\n   */\n\n  UUID.FIELD_SIZES = [32, 16, 16, 8, 8, 48];\n  /**\n   * Creates a version 4 {@link UUID} object.\n   * @returns {UUID} Version 4 {@link UUID} object.\n   * @since 3.0\n   */\n\n  UUID.genV4 = function () {\n    var rand = UUID._getRandomInt;\n    return new UUID()._init(rand(32), rand(16), // time_low time_mid\n    0x4000 | rand(12), // time_hi_and_version\n    0x80 | rand(6), // clock_seq_hi_and_reserved\n    rand(8), rand(48)); // clock_seq_low node\n  };\n  /**\n   * Converts a hexadecimal UUID string to a {@link UUID} object.\n   * @param {string} strId Hexadecimal UUID string (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n   * @returns {UUID} {@link UUID} object or null.\n   * @since 3.0\n   */\n\n\n  UUID.parse = function (strId) {\n    var r,\n        p = /^\\s*(urn:uuid:|\\{)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{2})([0-9a-f]{2})-([0-9a-f]{12})(\\})?\\s*$/i;\n\n    if (r = p.exec(strId)) {\n      var l = r[1] || \"\",\n          t = r[8] || \"\";\n\n      if (l + t === \"\" || l === \"{\" && t === \"}\" || l.toLowerCase() === \"urn:uuid:\" && t === \"\") {\n        return new UUID()._init(parseInt(r[2], 16), parseInt(r[3], 16), parseInt(r[4], 16), parseInt(r[5], 16), parseInt(r[6], 16), parseInt(r[7], 16));\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Initializes a {@link UUID} object.\n   * @private\n   * @constructs UUID\n   * @param {number} [timeLow=0] time_low field (octet 0-3, uint32).\n   * @param {number} [timeMid=0] time_mid field (octet 4-5, uint16).\n   * @param {number} [timeHiAndVersion=0] time_hi_and_version field (octet 6-7, uint16).\n   * @param {number} [clockSeqHiAndReserved=0] clock_seq_hi_and_reserved field (octet 8, uint8).\n   * @param {number} [clockSeqLow=0] clock_seq_low field (octet 9, uint8).\n   * @param {number} [node=0] node field (octet 10-15, uint48).\n   * @returns {UUID} this.\n   */\n\n\n  UUID.prototype._init = function () {\n    var names = UUID.FIELD_NAMES,\n        sizes = UUID.FIELD_SIZES;\n    var bin = UUID._binAligner,\n        hex = UUID._hexAligner;\n    /**\n     * UUID internal field values as an array of integers.\n     * @type {number[]}\n     */\n\n    this.intFields = new Array(6);\n    /**\n     * UUID internal field values as an array of binary strings.\n     * @type {string[]}\n     */\n\n    this.bitFields = new Array(6);\n    /**\n     * UUID internal field values as an array of hexadecimal strings.\n     * @type {string[]}\n     */\n\n    this.hexFields = new Array(6);\n\n    for (var i = 0; i < 6; i++) {\n      var intValue = parseInt(arguments[i] || 0);\n      this.intFields[i] = this.intFields[names[i]] = intValue;\n      this.bitFields[i] = this.bitFields[names[i]] = bin(intValue, sizes[i]);\n      this.hexFields[i] = this.hexFields[names[i]] = hex(intValue, sizes[i] >>> 2);\n    }\n    /**\n     * UUID version number.\n     * @type {number}\n     */\n\n\n    this.version = this.intFields.timeHiAndVersion >>> 12 & 0xF;\n    /**\n     * 128-bit binary string representation.\n     * @type {string}\n     */\n\n    this.bitString = this.bitFields.join(\"\");\n    /**\n     * Non-delimited hexadecimal string representation (\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\").\n     * @type {string}\n     * @since v3.3.0\n     */\n\n    this.hexNoDelim = this.hexFields.join(\"\");\n    /**\n     * Hexadecimal string representation (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n     * @type {string}\n     */\n\n    this.hexString = this.hexFields[0] + \"-\" + this.hexFields[1] + \"-\" + this.hexFields[2] + \"-\" + this.hexFields[3] + this.hexFields[4] + \"-\" + this.hexFields[5];\n    /**\n     * URN string representation (\"urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n     * @type {string}\n     */\n\n    this.urn = \"urn:uuid:\" + this.hexString;\n    return this;\n  };\n  /**\n   * Converts an integer to a zero-filled binary string.\n   * @private\n   * @param {number} num\n   * @param {number} length\n   * @returns {string}\n   */\n\n\n  UUID._binAligner = function (num, length) {\n    var str = num.toString(2),\n        i = length - str.length,\n        z = \"0\";\n\n    for (; i > 0; i >>>= 1, z += z) {\n      if (i & 1) {\n        str = z + str;\n      }\n    }\n\n    return str;\n  };\n  /**\n   * Returns the hexadecimal string representation.\n   * @returns {string} {@link UUID#hexString}.\n   */\n\n\n  UUID.prototype.toString = function () {\n    return this.hexString;\n  };\n  /**\n   * Tests if two {@link UUID} objects are equal.\n   * @param {UUID} uuid\n   * @returns {boolean} True if two {@link UUID} objects are equal.\n   */\n\n\n  UUID.prototype.equals = function (uuid) {\n    if (!(uuid instanceof UUID)) {\n      return false;\n    }\n\n    for (var i = 0; i < 6; i++) {\n      if (this.intFields[i] !== uuid.intFields[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Nil UUID object.\n   * @type {UUID}\n   * @constant\n   * @since v3.4.0\n   */\n\n\n  UUID.NIL = new UUID()._init(0, 0, 0, 0, 0, 0); // }}}\n  // UUID Version 1 Component {{{\n\n  /**\n   * Creates a version 1 {@link UUID} object.\n   * @returns {UUID} Version 1 {@link UUID} object.\n   * @since 3.0\n   */\n\n  UUID.genV1 = function () {\n    if (UUID._state == null) {\n      UUID.resetState();\n    }\n\n    var now = new Date().getTime(),\n        st = UUID._state;\n\n    if (now != st.timestamp) {\n      if (now < st.timestamp) {\n        st.sequence++;\n      }\n\n      st.timestamp = now;\n      st.tick = UUID._getRandomInt(4);\n    } else if (Math.random() < UUID._tsRatio && st.tick < 9984) {\n      // advance the timestamp fraction at a probability\n      // to compensate for the low timestamp resolution\n      st.tick += 1 + UUID._getRandomInt(4);\n    } else {\n      st.sequence++;\n    } // format time fields\n\n\n    var tf = UUID._getTimeFieldValues(st.timestamp);\n\n    var tl = tf.low + st.tick;\n    var thav = tf.hi & 0xFFF | 0x1000; // set version '0001'\n    // format clock sequence\n\n    st.sequence &= 0x3FFF;\n    var cshar = st.sequence >>> 8 | 0x80; // set variant '10'\n\n    var csl = st.sequence & 0xFF;\n    return new UUID()._init(tl, tf.mid, thav, cshar, csl, st.node);\n  };\n  /**\n   * Re-initializes the internal state for version 1 UUID creation.\n   * @since 3.0\n   */\n\n\n  UUID.resetState = function () {\n    UUID._state = new UUIDState();\n  };\n\n  function UUIDState() {\n    var rand = UUID._getRandomInt;\n    this.timestamp = 0;\n    this.sequence = rand(14);\n    this.node = (rand(8) | 1) * 0x10000000000 + rand(40); // set multicast bit '1'\n\n    this.tick = rand(4); // timestamp fraction smaller than a millisecond\n  }\n  /**\n   * Probability to advance the timestamp fraction: the ratio of tick movements to sequence increments.\n   * @private\n   * @type {number}\n   */\n\n\n  UUID._tsRatio = 1 / 4;\n  /**\n   * Persistent internal state for version 1 UUID creation.\n   * @private\n   * @type {UUIDState}\n   */\n\n  UUID._state = null;\n  /**\n   * @private\n   * @param {Date|number} time ECMAScript Date Object or milliseconds from 1970-01-01.\n   * @returns {any}\n   */\n\n  UUID._getTimeFieldValues = function (time) {\n    var ts = time - Date.UTC(1582, 9, 15);\n    var hm = ts / 0x100000000 * 10000 & 0xFFFFFFF;\n    return {\n      low: (ts & 0xFFFFFFF) * 10000 % 0x100000000,\n      mid: hm & 0xFFFF,\n      hi: hm >>> 16,\n      timestamp: ts\n    };\n  }; // }}}\n  // create local namespace\n\n\n  function UUID() {} // for nodejs\n\n\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    module.exports = UUID;\n  }\n\n  return UUID;\n}(UUID); // vim: fdm=marker fmr&","map":null,"metadata":{},"sourceType":"script"}